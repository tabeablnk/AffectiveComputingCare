# -*- coding: utf-8 -*-
"""Emotion Recognition.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aUQ4uQUMa82YeKDqV9EzPLQoHuqP--J4
"""

import tensorflow as tf
import cv2
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, AveragePooling2D
from tensorflow.keras.layers import Activation, Dropout, Flatten, Dense
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras import applications
import numpy as np
from tensorflow.keras.utils import to_categorical  
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Input
from tensorflow.keras.models import Model
from tensorflow.keras.models import load_model
import matplotlib.pyplot as plt
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib import pyplot as plt
from scipy import interpolate

batch_size = 64
img_width,img_height = 48,48

#ORIGINAL CLASSES 0=Angry, 1=Disgust, 2=Fear, 3=Happy, 4=Sad, 5=Surprise, 6=Neutral
num_classes = 3 

CSV_FILE="../assets/fer2013.csv"

"""## Load Google Drive"""

from google.colab import drive
drive.mount('/content/drive')

CSV_FILE="/content/drive/My Drive/fer2013.csv" # please adjust the path
model_path = '/content/drive/My Drive/emotion_model_small.h5' # please adjust the path

"""## Prepare data """

def _load_fer():
    # Load training and eval data
    df = pd.read_csv(CSV_FILE, sep=',')
    # 0=Angry, 1=Disgust, 2=Fear, 3=Happy, 4=Sad, 5=Surprise, 6=Neutral
    # 0=Neutral, 1=Happy, 2=Sad
    df = pd.read_csv(CSV_FILE, sep=',')
    print("Origin Size:", len(df))

    #drop all angry, disgust, fear, surprise
    df.drop(df.loc[df['emotion']==0].index, inplace=True)
    df.drop(df.loc[df['emotion']==1].index, inplace=True)
    df.drop(df.loc[df['emotion']==2].index, inplace=True)
    df.drop(df.loc[df['emotion']==5].index, inplace=True)

    #label emotions new
    df.loc[df['emotion'] == 3, 'emotion'] = 1
    df.loc[df['emotion'] == 4, 'emotion'] = 2
    df.loc[df['emotion'] == 6, 'emotion'] = 0
    print("End Size:", len(df))
    train_df = df[df['Usage'] == 'Training']
    eval_df = df[df['Usage'] == 'PublicTest']
    return train_df, eval_df

def _preprocess_fer(df,
                    label_col='emotion',
                    feature_col='pixels'):
    labels, features = df.loc[:, label_col].values.astype(np.int32), [
        np.fromstring(image, np.float32, sep=' ')
        for image in df.loc[:, feature_col].values]
    
    labels = [to_categorical(l, num_classes=num_classes) for l in labels]

    features = np.stack((features,) * 3, axis=-1)
    features /= 255
    features = features.reshape(features.shape[0], img_width, img_height, 3)

    return features, labels

# Load fer data
train_df, eval_df = _load_fer()

# preprocess fer data
x_train, y_train = _preprocess_fer(train_df)
x_valid, y_valid = _preprocess_fer(eval_df)

print(x_train.shape[0], 'train samples')
print(x_valid.shape[0], 'valid samples')

"""## Show train image"""

img = x_train[24]
print(img.shape)
plt.imshow(img)
plt.show()
y_train[24]

"""## Load images and labels in image generator"""

gen = ImageDataGenerator(
        rotation_range=40,
        width_shift_range=0.2,
        height_shift_range=0.2,
        shear_range=0.2,
        zoom_range=0.2,
        horizontal_flip=True,
        fill_mode='nearest')

train_generator = gen.flow(x_train, y_train, batch_size=batch_size)
predict_size_train = int(np.math.ceil(len(x_train) / batch_size))

gen = ImageDataGenerator()
valid_generator = gen.flow(x_valid, y_valid, batch_size=batch_size)
predict_size_valid = int(np.math.ceil(len(x_valid) / batch_size))

"""## Define Model with input, output and several layers"""

model = Sequential()
model.add(Conv2D(32, (3, 3), padding='same', input_shape=(img_width, img_height, 3)))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.3))

model.add(Conv2D(64,(3, 3), padding='same'))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.3))

model.add(Conv2D(128,(3, 3), padding='same'))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.3))

model.add(Flatten())  # this converts our 3D feature maps to 1D feature vectors
model.add(Dense(256))
model.add(Dropout(0.5))
model.add(Dense(num_classes))
model.add(Activation('softmax'))

model.compile(loss='categorical_crossentropy', optimizer=tf.keras.optimizers.Adam(lr=0.001), metrics=['accuracy'])
model.summary()

hist = model.fit(train_generator, 
                    steps_per_epoch=predict_size_train * 1, 
                    epochs=135,
                    validation_data=valid_generator,
                    validation_steps=predict_size_valid)
model.save('/content/drive/My Drive/models/emotionmodel_final_125_64')
import matplotlib.pyplot as plt
print(model)
plt.plot(hist.history['accuracy'])
plt.plot(hist.history['val_accuracy'])
plt.title('model accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'val'], loc='upper left')
plt.show()
plt.savefig('/content/drive/My Drive/plt_4.png')

"""# Create Confusion Matrix"""

from sklearn.metrics import confusion_matrix
x_valid, y_valid
y_pred = model.predict(x_valid)
predicted_category = tf.argmax(y_pred, axis=1)
true_category = tf.argmax(y_valid, axis=1)

confm = confusion_matrix(predicted_category, true_category)

import numpy as np
import matplotlib.pyplot as plt
import numpy as np
import itertools

def plot_confusion_matrix(cm,
                      target_names,
                      title='Confusion matrix',
                      cmap=None,
                      normalize=True):
    accuracy = np.trace(cm) / float(np.sum(cm))
    misclass = 1 - accuracy

    if cmap is None:
        cmap = plt.get_cmap('Blues')

    plt.figure(figsize=(8, 6))
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()

    if target_names is not None:
        tick_marks = np.arange(len(target_names))
        plt.xticks(tick_marks, target_names, rotation=45)
        plt.yticks(tick_marks, target_names)

    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]


    thresh = cm.max() / 1.5 if normalize else cm.max() / 2
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        if normalize:
            plt.text(j, i, "{:0.4f}".format(cm[i, j]),
                      horizontalalignment="center",
                      color="white" if cm[i, j] > thresh else "black")
        else:
            plt.text(j, i, "{:,}".format(cm[i, j]),
                      horizontalalignment="center",
                      color="white" if cm[i, j] > thresh else "black")


    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label\naccuracy={:0.4f}; misclass={:0.4f}'.format(accuracy, misclass))
    plt.show()

plot_confusion_matrix(cm = confm, 
                      normalize   = False,
                      target_names = ['neutral', 'happy', 'sad'],
                      title        = "Confusion Matrix")